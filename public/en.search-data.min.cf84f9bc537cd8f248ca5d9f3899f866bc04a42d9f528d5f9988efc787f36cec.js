'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/books/','title':"Books",'section':"Docs",'content':"Books #    Debt - 5000 Years -Google Talk by Author\nSacred Economics - Google Talk by Author\nState and Revolution\nWho Gets What and Why - Mechanism Design\nRadical Market\n"});index.add({'id':1,'href':'/docs/economics/','title':"Economics",'section':"Docs",'content':"Economics #  Links #  Cryptoeconomics\nTokenizing Shares ERC-884\nTime Locked Tokens\n  Mechanism Design #  Basics\nGame Theory #  "});index.add({'id':2,'href':'/docs/markdown/','title':"Markdown",'section':"Docs",'content':"Markdown #  Notes #  Links #  Markmap\n"});index.add({'id':3,'href':'/docs/back-end/','title':"Back-End",'section':"Docs",'content':"Links #  "});index.add({'id':4,'href':'/docs/blockchain/','title':"Blockchain",'section':"Docs",'content':"Blockchain #  Blockchain has been something I have been passionate about for a few years now. Here is a little bit of what I know.\nEthereum #  Ethereum Foundation\nMore Bonding Curves\nBonding Curves\nQuadratic Arithmetic Programs\nLex Dao\nMolloch Dao\nEthereum Foundation Research Goals\nResearch Forum\n[https://www.theblockchainmonitor.com/](Blockchain Monitior Weekly Articles) [https://www.youtube.com/watch?v=95_RmIAqRy0](DEFI exploits and smart contract security ~ Video)\nSideChains #  EVM Side Chains Avalanche\nCelo\nSolana\nNEAR\nPolkadot\nFindora\nBitcoin #  Script Bitcoin Script\nBTC\nBSV #  Developer Links for BSV Money Button - Developer tools\nMoney Button\nScrypt\nUniwriter - BSV Developer\n"});index.add({'id':5,'href':'/docs/blockchain/dao/','title':"DAOs",'section':"Blockchain",'content':"DAOs #  Created: Aug 18, 2020 6:32 PM\n DAO Canvas (Business Plan to determine how a DAO should be made)  Note: We want to make a for profit DAO this relies on taxing or some form of monetization to people in or not in the DAO who are using a service provided by the DAO, this could be a tool, knowledge, etc.\n  For Profit relies on funding coming in to the DAO and to a central bank where it then distributed or kept by the DAO\n  Componnets\n Central DAO register( Allows voting , adding etc ) Contract in control of voting What do people vote with? We need token. A bank in the form of a contract upgradability? dtl wrappers    Governance\nLinks: #  [http://thesecretlivesofdata.com/raft/](Governance Database) [https://github.com/thelastjosh/govbase](Govbase Governance Tool Database) [https://www.poap.xyz/](Proof of Attendance)\n Quadratic Voting? Normal voting? Time based voting  Voting Catergories\n Add Member Vote for changes manual updates  For Profit DAO #  Examples: #   The LAO\nMetaCartel Ventures\nModel Example #   An example of a for-profit dao and some the requirements needed.\n Money to pay developers Open participation in providing liquidity and earning yield long term upsides for founders  Steps: #   Compile group of parties prior to dao launch , and launch dao with them as members Require deposits and issue shares as see fit Scope product and get quotes from developers Dao picks dev and approves proposal to pay for work, could be funds from treasury, shares, etc. Product is build and launched. The liquidity pool are only made from the DAO to start. This guarantees the early yield but is also a safety measure A predetermined time or event marks the removal of the liquidity pool contribution limits All non-DAO contributions are issued with a small tax.  Notes: #  Taxes incentives long term liquidity, immediately deposition and withdrawing would net a loss. Timing is everything, careful planning is needed to make sure that good traction is got before the liquidity pool is open that way there is a \u0026ldquo;moat\u0026rdquo; of sorts against a forked 0-taxed version.\n  "});index.add({'id':6,'href':'/docs/front-end/','title':"Front-End",'section':"Docs",'content':"Front-End #  Frameworks #  "});index.add({'id':7,'href':'/docs/hardware/','title':"Hardware",'section':"Docs",'content':"Hardware #   Links: #  [https://www.pine64.org/pinephone/])(PinePhone (Open Source Phone))\n"});index.add({'id':8,'href':'/docs/math/','title':"Math",'section':"Docs",'content':"Math #  Notes #  [https://en.wikipedia.org/wiki/Lp_space](   \\( L^p \\)  Space Metric Space )\n   \\( d(x,y) = [|x_1 - y_|]^p \u0026#43; |x_2 - y_2|^P]^(1/p) \\)    Taxicab Metric → P = 1\n  Euclidean Metric → P = 2\n  Linear Algebra #  "});index.add({'id':9,'href':'/docs/zk_proof/np/','title':"NP and Complexity-Theoretic Reduction",'section':"Zero Knowledge Proofs",'content':"NP and Complexity-Theoretic Reduction #  zkSNARKS only work for specific problems about polynomials.\nLet us a function that only ouputs 0 or 1 is called a problem.\nMeasuring the complexity to solve a given function we can measure the machine implementation M of a mathematical function f, ie, count the number of steps it takes to compute f on a specific input x.\nKnown as the runtime of M on x. Thus a n^2 program is a program that takes n^2 steps on input size n.\nTwo main class of problems in complexity theory are P and NP #  P is a class of problems L that have polynomial time programs\nThere are zkSNARKS for all problems in the class NP. All problems in NP always have a certain structure.\nNP is the class of problems L that have a polynomial-time program V that can be used to verify a fact given a polynomially sized witness. L(x) = 1 iff there exists some polynomially sized string such that V(x,w) =1\nFor any NP-problem L there is a so-called reduction function computable in polynomial time such that L(x) = SAT(f(x))\ni.e a compiler taking source code from one language and transforming it into a equivalent language is a reduction function. think high level language to assembly.\n"});index.add({'id':10,'href':'/docs/zk_proof/parameter_generation/','title':"Parameter Generation",'section':"Zero Knowledge Proofs",'content':"Parameter Generation #  IN zcash the circuit (transaction verifier) is fixed and thus the polynomials for the QSP are fixed which allow the setup to be prreformed only once. Varying in only the input u.\nZcash zk proofs rely on public parameters which allow users to construct and verify private transactions.\nMust be set up in a set up phase, random numbers are sampled and refered to as toxic waste to construct parameters, this waste must then be destroyed\nMulti-party computation ceremonies ensure that toxic waste does not come into existence through multiple step independent parties construction of a ceremony. For the final parameter to be compromised all the participants would have to be compromised.\nSapling #  Zcash second set of public parameters\nPowers of Tau #  A multi-party computation ceremony which reached its conclusion in early 2018, coordinated through a public mailing list\nSapling MPC #  The Zcash Company hosted MPC for the final parameter construction.over 90 contributions were completed and the final parameter was included in the 2.0.0 release\nOverview #  All participants play a similiar role having their machines randomly sample a part of the toxic waste and this part or shard to perform computations. COmmunication takes place during this period and is not seen as sensitive. However they do no communicate directly but through a coordinated server that acts as a bridge.\nCommitment Phase #  Each node randomly generate their shard of the toxic waste providing random text to provide additional entropy to the Linux RNG machine. A special key is then consturcted to verify the evaluation and bind participants.\nStage 1/ Power of Tau #  The coordination initializes the initial state and each participant performs a transformation on this state which is passed to the next participant.\nStage 2 #  Similar to Stage 1 but more complex and takes much longer for each participant to complete their role.\nStage 3 #  Similar but less expensive computations and faster then either previous stage.\n"});index.add({'id':11,'href':'/docs/zk_proof/qsp/','title':"Quadratic Span Program",'section':"Zero Knowledge Proofs",'content':"QSP (Quadratic Span Program) #  A Quadratic Span Program consists of a set of polynomials and a task is to a find a linear combination of those that is a multiple of another given polynomial.\nA QSP over a field F for inputs of length n consists of\n a set of polynomials over the field F a polynomial t over F (target polynomial) an injective function  The task is roughly multiply the polynomials by factors and add them so that the sum , the linear combination is a multiple of t. For each binary input string u the function f restricts the polynomial that can be used.\nThe reduction from generic computations or circuits to SQP is the hard part as it has to be done in a efficient way to get it as small as possible.\nSetup detail #  The setup generates the common reference string CRS the verifier chooses a random field element s and encrypts the values of the polynomials at the given point. The verifier uses some specific encryption E and publishes E(v_k(s)) and E(w_k(s)) in the CRS. The CRS also contains several other values which makes the verification more efficient and adds the zk property. The encryption E has certain homeomorphic propertyes that the prover can computer E(v(s)) without knowing v_k(s)\nEncrypted evaluation of a polynomial at secret points #  Fix a group, typically an elliptic curve and a generator g. (Note that a group element is called a generator if there is a number n st the list   \\(g^0 g^1 g^{n-1} \\)  contains all elements in the group. The encryption E(x) := g^x.\nThe verifier chooses a secret field s and publishes as part of CRS\nE(s^0), E(s^1),\u0026hellip;. E(s^d) is the max degree of all polynomials.\nS then HAS to be forgotten\nUsing these values, the prover can computer E(f(s) for arbitrary polynomials f wihtout knowing s. Assume our polynomial is  \\(f(x) = 4x^2 \u0026#43; 2x \u0026#43;4 \\)  and we want to computer E(f(s) then we get  \\( E(f(s)) = E(4s^2 \u0026#43;2s\u0026#43;4) = g^4s^2 \u0026#43;2s \u0026#43;4 = E(s^2)^4* E(s^1)^2 * E(s^0)^4 \\)  which can be computed from CRS\nAnother secret field element a is needed and we need to publish  \\( E(as^0), E(as^1) E(as^d) \\)  and a is then destroyed\nA prover publishes A:=E(Fs) and B:= E(af(s) and the verifier has to check that these values match. The verifier does this through a pairing function e. This has to be chosen together without the elliptic curve thus  \\( e(g^x, g^y) = e(g,g)^(xy)\\)   \\( e(A, g^a) = e(g^f(s), g^a) = e(g, g) ^a f(s) \\)   \\( e(B, g) = e(g^(af(s), g) = e(g,g)^(a, f(s) \\)  "});index.add({'id':12,'href':'/docs/zk_proof/rsa_intermission/','title':"RSA Intermission",'section':"Zero Knowledge Proofs",'content':"RSA Intermission #  a + b = c (mod n) == (a+b) mod n = c mod n\nProver comes up with\np,q two random secret primes\nn := pq\nd: random number such that 1 \u0026lt; d \u0026lt; n-1\ne: a number such that de congruent 1 (mod (p-1)(q-1))\nc^d = (m^e % n)^d = m^(ed) mod n\nRSA is multipliacateively homorphic. Two operations are homomorphic if you can exchange their order without affect the result.\nThus the product of the encryption of the two messages is equal to the encryption of the product of the messages\nThe prover knows some secret numbers x and y and computers their product but only sends the encryption version such that a=E(x), b = E(y), and c = E(x,y) to the verifier. The verifier now checks that (a b) % n congruent c % n and the only thing learned is the encrypted version of the product and its correctness\n"});index.add({'id':13,'href':'/docs/zk_proof/','title':"Zero Knowledge Proofs",'section':"Docs",'content':"Zero Knowledge Proofs #  Zcash is derived from the fact that shielded transactions can be fully encrypted on the blockchain but still verified using ZK-SNARK proofs\nzk-SNARK = Zero Knowledge Succinct Non-Interactive Argument of Knowledge, and refers to a proof construction where possession of a secret key can be verified without any interaction between the prove and verified or revealing any info. i.e: Proves proves to the verified that a statement is true.\n Succint: the sizes of the messages are tiny in comparison to the length of the actual computation Non-interactive, there is no or little interaction. For zksnarks there is usually a setup phase and after that a single message from the prover to the verifier. Furthermore, SNARKS often have so called public verifier properties meaning that anyone can verify without interacting anew ARguments, the verifier is only protected against computationally limited provers. Provers with enough power can create proofs about wrong statements. I.e computational soundness of Knowledge, it is not possible for the prover to consturct a proof without knowing a certain so called witness, (address she wants to spend from, the preimage of hash function, or the path to a certain Merkle-tree node) zero-knowdge prefix requires that during the interaction the verifier learns nothing apart from the validity of the statement, especially not the witness string.  Current efficient non-interactive zk proofs rely on a setup phase where a reference string is shared between users.\nNeither the size of the witness string nor the computational efort require to verify the QSP play any role in verification. This means that SNARK verify complex problems and very simple problems take the same effort\nPublic parameters are generated through a parameter generation ceremony.\nParameter Generation #  Parameter Generation\nInstead of computing   \\(v_a w_b \\)  and their product a verifier chooses a secret random point s , referred to as toxic waste in zcash, and computes t(S)  \\(v_k(s)\\)  and  \\(w_k(S) \\)  for all k and from them  \\(v_a(s) \\)  and  \\( w_b(s) \\)  and only  \\( t(S)h(s) = v_a(s)w_b(s)\\)  . A bunch of polynomial additions, multiplications with a scalar and polynomial product can be simplifies to field multiplications and additions.\nOverview #  Computation → Arithmetic Circuit → R1CS → QAp → zk-SNARK\nR1CS = Rank 1 Constraint System and checks that the values are \u0026ldquo;traveling correctly\u0026rdquo;\nCreating shielded transactions in Zcash is one example of zk-SNARKS. But it can be used to verify any relation without disclosing inputs or leaking information.\n4 Main ingredients:\nA). Encoding as a polynomial problem\nThe program is converted into a quadratic equation of polynomials\n \\(t(x)h(x) = w(x)v(x)\\)  where the equality holds iff the program is computer correctly. The prover WANTS to convince the verifier that the equality holds.\nB). Succinctness by random sampling\nThe verifies chooses a secret evaluation point s to reduce the problem from multiplying polynomials and verifying function equality to multiplication and equality of numbers\n \\(t(s)h(s) = w(s)v(s)\\)  C). Homomorphic encoding/encryption\nAn encoding function E is used that has some homomorphic properties that allows the prover to computer E(t(s)), E(h(s)), E(w(s)), E(v(s)) without knowing s. she only knows E(s)\nD). Zero knowledge\nThe prover permutes the values E(t(S), E(h(s)), E(w(s)), E(v(S)) by multiplying with a number so that the verifier can still check for the correct structure without knowing the actual value.\n \\(t(s)h(s) =w(s)v(s) === t(s)h(s)k = w(s)v(s)k\\)  For a random secret number k where k not 0 then these two are equivalent. However it is impossible to derive t(s)h(s) or w(s)v(s) with the k\nRSA Intermission\nNP and Complexity-Theoretic Reduction\nQSP Quadratic Span Program\nEthereum #  Development #  Other #  "});index.add({'id':14,'href':'/docs/os/','title':"OS",'section':"Docs",'content':"OS #    Windows #    Linux #    Gnome\n"});})();